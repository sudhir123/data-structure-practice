package com.prac.home.algoexpert.hard;
/**
 * given a two dimensional array (matrix) and integer defines the size. write a method returning the maximum sum that can be generated by
 * size * size matrix.
 */
public class MaximumSubMatrix {
    public static void main(String[] args) {
        MaximumSubMatrix m = new MaximumSubMatrix();
        System.out.println(m.maximumSumSubmatrix(new int[][]{
                {2,4},
                {5,6},
                {-3,2},
        }, 2));
    }
    // better approach. using dynamic programming. Declare same length and breadth matrix.
    public int maximumSumSubmatrix(int[][] matrix, int size) {
        int[][] result= new int[matrix.length][matrix[0].length];
        resultMatrixPopulate(matrix, result);
        return resultMatrixMaxSum(result, size);
    }

    public void resultMatrixPopulate(int[][]matrix, int[][]result){
        result[0][0]=matrix[0][0];
        int row=0, col=1;
        while (col<matrix[0].length){
            result[row][col]= result[row][col-1]+matrix[row][col];
            col++;
        }
        row=1; col=0;
        while (row<matrix.length){
            result[row][col]= result[row-1][col]+matrix[row][col];
            row++;
        }
        for (int r=1; r< matrix.length; r++){
            for (int c =1; c< matrix[0].length; c++){
                result[r][c]= (matrix[r][c] +(result[r-1][c] + result[r][c-1]) )- result[r-1][c-1];
            }
        }
    }
    public int resultMatrixMaxSum(int[][]result, int size){
        int maxSumSoFar= Integer.MIN_VALUE;
        for (int row=size-1; row< result.length; row++){
            for (int col=size-1; col< result[0].length; col++){
                if (col-size >= 0 && row-size>=0){
                    maxSumSoFar= Math.max(maxSumSoFar, ((result[row][col]-(result[row][col-size]+result[row-size][col])) + result[row-size][col-size]));
                }else if (col-size >= 0){
                    maxSumSoFar= Math.max(maxSumSoFar, result[row][col]-result[row][col-size]);
                }else if (row-size>=0){
                    maxSumSoFar= Math.max(maxSumSoFar, result[row][col]-result[row-size][col]);
                }else{
                    maxSumSoFar= Math.max(maxSumSoFar, result[row][col]);
                }
            }
        }
        return maxSumSoFar;
    }




    // this is naive approach ..brute force kinda.
    // time complexity is w*h * sixe^2 ...because for every matrix we need to calculate the sum which size^2 traversing each element.
    // recursive select matrix by running x-> x+1 or y+1, keeping limits. and call sum for spiral elements.
    /*public int maximumSumSubmatrix(int[][] matrix, int size) {
        // Write your code here.
        int maxSum = subMatrix(matrix, size, 0, 0, Integer.MIN_VALUE);
        return maxSum;
    }*/

    public int subMatrix(int[][] matrix, int size, int currentRow, int currentCol, int maxSumSoFar) {

        if (currentRow + size >= matrix.length+1 || currentCol + size >= matrix[0].length+1) {
            return -1;
        }
        System.out.println( "currentRow-> "+currentRow +" currentCol-> "+currentCol);
        int[][] subMatrix = new int[currentRow + size][currentCol + size];
        for (int row = currentRow; row < currentRow + size; row++) {
            for (int col = currentCol; col < currentCol + size; col++) {
                subMatrix[row][col] = matrix[row][col];
            }
        }

        maxSumSoFar = Math.max(maxSumSoFar, sumSpiralMatrix(subMatrix));
        maxSumSoFar = Math.max(maxSumSoFar,subMatrix(matrix, size, currentRow + 1, currentCol, maxSumSoFar));
        maxSumSoFar = Math.max(maxSumSoFar,subMatrix(matrix, size, currentRow, currentCol + 1, maxSumSoFar));
        return maxSumSoFar;
    }

    public boolean limits(int[][] matrix, int currentRowIdx, int currentColIdx) {
        return false;
    }

    public int sumSpiralMatrix(int[][] matrix) {
        int sum =0;
        for (int row = 0; row < matrix.length; row++) {
            for (int col = 0; col < matrix[0].length; col++) {
                sum+=matrix[row][col];
            }
        }
        return sum;
    }
}
